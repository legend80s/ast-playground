/**
 * Auto-generated by watching your ts or js and both src files.
 * DO NOT MODIFY IT BY YOURSELF!
 */
declare module 'herbjs' {
  export function Store({ state, getters, mutations, actions }: IHerbAppStore): void;
}

// static
// type utils
type IPayloadArgumentType<T> = T extends (_: any, payload: infer P) => any ? P : any;
// 没有 ReturnType 严格
type IReturnType<F> = F extends (...args: any) => infer R ? R : F;
type UnPackPromise<P> = P extends Promise<infer V> ? V : P;

type IDispatchPayload<IActions, Action extends keyof IActions> = IPayloadArgumentType<IActions[Action]>;
type IDispatchReturnType<IActions, Action extends keyof IActions> = UnPackPromise<IReturnType<IActions[Action]>>;

type IActionParams<IState, IGlobalState, IMutations, IOtherActions> = {
  state: IState;
  global: IGlobalState;

  dispatch<Action extends keyof IOtherActions>(key: Action, payload?: IDispatchPayload<IOtherActions, Action>):
    Promise<IDispatchReturnType<IOtherActions, Action>>,

  commit<Mutation extends keyof IMutations>(key: Mutation, payload?: IPayloadArgumentType<IMutations[Mutation]>):
    void;
}

type IHerbAppState<IState> = Partial<IState>;
type IHerbAppGetters<IGetters, IState, IGlobalState> = {
  [Getter in keyof IGetters]: (state: IState, getters: Omit<IGetters, Getter>, global: IGlobalState) =>
    IReturnType<IGetters[Getter]>;
};
type IHerbAppMutations<IMutations, IState> = {
  [Mutation in keyof IMutations]: (state: IState, payload: IPayloadArgumentType<IMutations[Mutation]>) => void;
}
type IHerbAppActions<IActions, IState, IGlobalState, IMutations> = {
  [Action in keyof IActions]: (
    { state, commit, global, dispatch }:
      IActionParams<IState, IGlobalState, IMutations, Omit<IActions, Action>>,
    payload: IPayloadArgumentType<IActions[Action]>,
  ) => IReturnType<IActions[Action]>;
}

// @ts-ignore UserOptions will be generated after scann the js/ts src files
type IUserState = UserOptions['state'];
// @ts-ignore as getters may not exist
type IUserGetters = UserOptions['getters'];
// @ts-ignore as actions may not exist
type IUserActions = UserOptions['actions'];
// @ts-ignore as mutations may not exist
type IUserMutations = UserOptions['mutations'];

interface IHerbAppStore {
  state?: IHerbAppState<IUserState>;
  getters?: IHerbAppGetters<IUserGetters, IUserState, IUserGlobalState>;
  mutations?: IHerbAppMutations<IUserMutations, IUserState>;
  actions?: IHerbAppActions<IUserActions, IUserState, IUserGlobalState, IUserMutations>;
}

type IUserGlobalState = Record<string, any>;

type UserOptions = {
  state: {
    a: number;
    b: string;
  };
  getters: {
    c(state: any, getters: any, global: any): any;
    d(): string;
  };
  mutations: {
    e(state: any, payload: any): void;
    f(state: any, payload: any): void;
    g(): void;
  };
  actions: {
    action1({ state, commit, global, dispatch }: {
      state: any;
      commit: any;
      global: any;
      dispatch: any;
    }, payload: any): any;
    action2({ state, commit, global, dispatch }: {
      state: any;
      commit: any;
      global: any;
      dispatch: any;
    }, payload: any): Promise<any>;
    action3({ state, commit, global, dispatch }: {
      state: any;
      commit: any;
      global: any;
      dispatch: any;
    }, payload: any): string;
    action4(): string;
  };
};
